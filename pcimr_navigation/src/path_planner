#!/usr/bin/env python3

import rospy
import math
import numpy as np 

from std_msgs.msg import String
from geometry_msgs.msg import Point, PoseStamped, Quaternion
from nav_msgs.msg import Path, OccupancyGrid, MapMetaData
from visualization_msgs.msg import Marker

class PathPlanner():

    def __init__(self):
 
        self.goal = Point()
        self.goal.x = 0.0
        self.goal.y = 0.0
        self.goal.z = 0.0
        self.map = OccupancyGrid()
        self.map_array = []
        self.robot_pos = Point()

        # Initialize Subscribers
        self.sub_robot_pos = rospy.Subscriber('/robot_pos', Point, self.cb_robot_pos)
        self.sub_map = rospy.Subscriber('/map', OccupancyGrid, self.cb_map)
        self.sub_goal = rospy.Subscriber('/move_base_simple/goal', PoseStamped, self.cb_goal)


        # Initialize Publishers
        self.pub_path_cells = rospy.Publisher('/global_path', Path, queue_size=10,latch=True)
        self.pub_goal_marker = rospy.Publisher('/visualization/goal', Marker, queue_size=10)
        self.pub_path_line = rospy.Publisher('/visualization/plan', Marker,queue_size=10)

        # Setup Messages for publishing
        self.msg_goal_marker = Marker()
        self.msg_goal_marker.header.frame_id = "map"
        self.msg_goal_marker.ns = "goal_pos"
        self.msg_goal_marker.id = 1
        self.msg_goal_marker.type = Marker.CUBE
        self.msg_goal_marker.action = Marker.ADD
        self.msg_goal_marker.scale.x = 1
        self.msg_goal_marker.scale.y = 1
        self.msg_goal_marker.scale.z = 0.2
        self.msg_goal_marker.color.a = 1.0
        self.msg_goal_marker.color.r = 1.0
        self.msg_goal_marker.color.g = 0.0
        self.msg_goal_marker.color.b = 0.0
        self.msg_goal_marker.pose.orientation = Quaternion(0, 0, 0, 1)

        self.msg_path = Path()
        self.msg_path.header.frame_id = "map" 
        

        self.msg_line_strip = Marker()
        self.msg_line_strip.header.frame_id = "map"
        self.msg_line_strip.ns = "line_pos"
        self.msg_line_strip.id = 2
        self.msg_line_strip.type = Marker.LINE_STRIP
        self.msg_line_strip.action = Marker.ADD
        self.msg_line_strip.scale.x = 1
        self.msg_line_strip.scale.y = 1
        self.msg_line_strip.scale.z = 0.2
        self.msg_line_strip.color.a = 1.0
        self.msg_line_strip.color.r = 0.0
        self.msg_line_strip.color.g = 0.0
        self.msg_line_strip.color.b = 1.0

    class Node():
        # Initialize
        def __init__(self, position:(), parent:()):
            self.position = position
            self.parent = parent
            self.g = 0
            self.h = 0
            self.f = 0

        # Compare
        def __eq__(self, other):
            return self.position == other.position
        
        # Sort
        def __lt__(self, other):
            return self.f < other.f

        # Print
        def __repr__(self):
            return('{0},{1}'.format(self.position, self.f))

        
    def cb_robot_pos(self, robot_pos):
        self.robot_pos = robot_pos
    
    def cb_map(self, map):
        self.map = map
        self.map_array = np.transpose(np.asarray(map.data, dtype=np.int8).reshape(map.info.width, map.info.height))
        
    def cb_goal(self, goal):

        #Discretize goal and set marker position
        self.goal.x = math.trunc(goal.pose.position.x)
        self.goal.y = math.trunc(goal.pose.position.y)

        self.msg_goal_marker.pose.position.x = self.goal.x + 0.5
        self.msg_goal_marker.pose.position.y = self.goal.y + 0.5

    def astar_search(self):
        # Lists for open and closed nodes
        open = []
        closed = []
   
        # Define start and goal node with position and parent
        start_node = PathPlanner().Node(self.robot_pos, None)
        goal_node = PathPlanner().Node(self.goal, None)
   
        # Initially, open consiststs solely of the start node
        open.append(start_node)

        while(len(open) > 0):
            # Sort list open in ascending order
            open.sort()
            # Get the node with the lowest cost
            current_node = open.pop(0)
            # Move current node to closed list
            closed.append(current_node)
            # Check if current node is a goal state
            if current_node == goal_node:
                path = []
                while(current_node != start_node):
                    print(current_node.position)
                    posestamped = PoseStamped()
                    posestamped.header.frame_id = "path"
                    posestamped.pose.position = current_node.position
                    posestamped.pose.orientation = Quaternion(0,0,0,1)
                    path.append(posestamped)
                    self.msg_line_strip.points.append(Point(current_node.position.x+0.5, current_node.position.y+0.5, 0.2))

                    current_node = current_node.parent
                # Return reversed path
                return path[::-1]
            
            # Expand current nodes by neighbors
            x = current_node.position.x
            y = current_node.position.y
    
            neighbors = [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]

        

            # Loop neighbors
            for next in neighbors:
                # Check if neighboring node is a accessible and within the map boundaries
                if(next[0] >= 0 and next[0] < 20 and next[1] >= 0 and next[1] < 20):
                    map_value = self.map_array[int(next[0])][int(next[1])]
                  
                    if(map_value != 0):
                        continue
                    
                    child_node = PathPlanner().Node(Point(next[0], next[1], 0.0), current_node)
                        

                    if(child_node in closed):
                        continue

                    # Generate Heuristics
                    child_node.g = abs(child_node.position.x - start_node.position.x) + abs(child_node.position.y - start_node.position.y)
                    child_node.h = abs(child_node.position.x - goal_node.position.x) + abs(child_node.position.y - goal_node.position.y)
                    child_node.f = child_node.g + child_node.h

                    if(self.add_to_open(open, child_node) == True):
                        open.append(child_node)

        return None

    def add_to_open(self, open, child_node):
        for node in open:
            if(child_node == node):
                if(child_node.f >= node.f):
                    return False
        return True

    def run(self, rate: float = 1):
        """
        Periodically publishes the move command based on the current path.

        @param rate: The rate at which the topics are published.
        """
        while not rospy.is_shutdown():
       
            # Publish messages
         
            if(len(self.map_array) != 0 and self.map_array[int(self.goal.x)][int(self.goal.y)] == 0):
                self.pub_goal_marker.publish(self.msg_goal_marker)
                self.msg_path.poses = self.astar_search()
                self.pub_path_cells.publish(self.msg_path)
                self.pub_path_line.publish(self.msg_line_strip)
            # Sleep for a while before publishing new messages. 
            if rate:
                rospy.sleep(1/rate)

if __name__ == "__main__":
    rospy.init_node('path_planner')

    path_planner_node = PathPlanner()
    path_planner_node.run(rate=1)


